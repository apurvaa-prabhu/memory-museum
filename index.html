<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Memory Museum (360)</title>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        color: #fff;
        min-height: 100vh;
        overflow: hidden;
        background: #020314;
        user-select: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: transparent;
      }

      #bg3d {
        position: fixed;
        inset: 0;
        z-index: -1;
        display: block;
      }

      .hud {
        position: fixed;
        top: 18px;
        left: 18px;
        z-index: 50;
        padding: 10px 12px;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.18);
        backdrop-filter: blur(10px);
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.55);
        max-width: min(520px, calc(100vw - 36px));
      }

      .hud h1 {
        font-size: 14px;
        font-weight: 650;
        letter-spacing: 0.4px;
        margin-bottom: 4px;
        opacity: 0.95;
      }

      .hud p {
        font-size: 12px;
        line-height: 1.35;
        opacity: 0.8;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-top: 8px;
        font-size: 12px;
        padding: 8px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(0, 0, 0, 0.25);
        opacity: 0.9;
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.85);
        box-shadow: 0 0 18px rgba(255, 255, 255, 0.55),
          0 0 40px rgba(140, 140, 255, 0.35);
      }

      .lightbox {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.92);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: 0.2s ease;
        z-index: 999;
        padding: 24px;
      }

      .lightbox.active {
        opacity: 1;
        pointer-events: auto;
      }

      .lightbox-card {
        width: min(980px, 92vw);
        display: grid;
        grid-template-columns: 1fr;
        gap: 14px;
        align-items: start;
      }

      @media (min-width: 860px) {
        .lightbox-card {
          grid-template-columns: 1.2fr 0.8fr;
          gap: 18px;
        }
      }

      .lightbox img {
        width: 100%;
        max-height: 78vh;
        object-fit: contain;
        border-radius: 16px;
        box-shadow: 0 0 60px rgba(255, 255, 255, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(10, 10, 20, 0.35);
      }

      .story {
        padding: 14px;
        border-radius: 16px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(10, 10, 20, 0.35);
        backdrop-filter: blur(10px);
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.55);
      }

      .story h2 {
        font-size: 14px;
        letter-spacing: 0.3px;
        margin-bottom: 8px;
      }

      .story p {
        font-size: 13px;
        line-height: 1.45;
        opacity: 0.9;
        white-space: pre-wrap;
      }

      .close {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-top: 12px;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.08);
        cursor: pointer;
        font-size: 13px;
        opacity: 0.9;
      }

      .close:hover {
        background: rgba(255, 255, 255, 0.12);
        opacity: 1;
      }
    </style>
  </head>

  <body>
    <canvas id="bg3d"></canvas>

    <div class="hud">
      <h1>Memory Museum • 360°</h1>
      <p>Drag to rotate the circle. Click/tap a photo to open it with its story.</p>
      <div class="pill">
        <span class="dot"></span>
        <span>Tip: slow drag = smooth spin • fast flick = momentum</span>
      </div>
    </div>

    <div class="lightbox" id="lightbox" aria-hidden="true">
      <div class="lightbox-card" role="dialog" aria-modal="true">
        <img id="lightboxImg" alt="Selected memory" />
        <div class="story">
          <h2 id="storyTitle">Memory</h2>
          <p id="storyText"></p>
          <div class="close" id="closeBtn">Close</div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <script>
      const MEMORIES = [
        { src: "img1.jpg", title: "Memory 1", story: "Dinner with roommates!" },
        { src: "img2.jpg", title: "Memory 2", story: "Sania’s 21st Birthday" },
        {
          src: "img3.jpg",
          title: "Memory 3",
          story: "Our roommates Angelina’s 22nd birthday",
        },
        { src: "img4.jpg", title: "Memory 4", story: "Apurvaa’s 21st Birthday" },
        {
          src: "img5.jpg",
          title: "Memory 5",
          story: "Our friend Angelina’s 21st birthday",
        },
        {
          src: "img6.jpg",
          title: "Memory 6",
          story: "Roommates visiting Sania’s hometown during fall",
        },
        { src: "img7.jpg", title: "Memory 7", story: "Angelina’s graduation" },
        {
          src: "img8.jpg",
          title: "Memory 8",
          story: "Desi Event at umass boston",
        },
        { src: "img9.jpg", title: "Memory 9", story: "Lunch with Roommates" },
        {
          src: "img10.jpg",
          title: "Memory 10",
          story: "All of the roommates in one picture",
        },
        { src: "img11.png", title: "Memory 11", story: "Galentines!" },
        { src: "img12.jpg", title: "Memory 12", story: "Diwali event at umb" },
      ];

      const lightbox = document.getElementById("lightbox");
      const lightboxImg = document.getElementById("lightboxImg");
      const storyTitle = document.getElementById("storyTitle");
      const storyText = document.getElementById("storyText");
      const closeBtn = document.getElementById("closeBtn");

      function openMemory(mem) {
        lightboxImg.src = mem.src;
        storyTitle.textContent = mem.title || "Memory";
        storyText.textContent = mem.story || "";
        lightbox.classList.add("active");
        lightbox.setAttribute("aria-hidden", "false");
      }

      function closeMemory() {
        lightbox.classList.remove("active");
        lightbox.setAttribute("aria-hidden", "true");
        lightboxImg.src = "";
        storyTitle.textContent = "Memory";
        storyText.textContent = "";
      }

      lightbox.addEventListener("click", (e) => {
        if (e.target === lightbox) closeMemory();
      });
      closeBtn.addEventListener("click", closeMemory);
      document.addEventListener("keydown", (e) => {
        if (e.key === "Escape") closeMemory();
      });

      const canvas = document.getElementById("bg3d");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x020314, 0.0048);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        1,
        1400
      );
      camera.position.set(0, 0, 0);
      camera.lookAt(0, 0, -1);

      function onResize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener("resize", onResize);
      onResize();

      function buildParticles(o) {
        const positions = new Float32Array(o.count * 3);
        for (let i = 0; i < o.count; i++) {
          const i3 = i * 3;
          positions[i3] = (Math.random() - 0.5) * o.rangeX * 2;
          positions[i3 + 1] = (Math.random() - 0.5) * o.rangeY * 2;
          positions[i3 + 2] = (Math.random() - 0.5) * o.rangeZ * 2;
        }
        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        return g;
      }

      const geometry = buildParticles({ count: 165000, rangeX: 980, rangeY: 520, rangeZ: 980 });
      const uniforms = { uTime: { value: 0 }, uMouse: { value: new THREE.Vector2(0, 0) } };

      const vertexShader = `
        uniform float uTime;
        uniform vec2 uMouse;
        varying float vNoise;

        void main(){
          vec3 p = position;
          float t = uTime * 0.45;

          float wave1 = sin(p.x * 0.05 + t) * 26.0;
          float wave2 = cos(p.y * 0.06 - t * 1.3) * 26.0;
          float wave3 = sin(p.z * 0.06 + t * 0.7) * 21.0;

          p.x += wave1 + wave3 * 0.3;
          p.y += wave2 + wave3 * 0.4;

          vec2 mouseWorld = vec2(uMouse.x * 520.0, uMouse.y * 300.0);
          float d = distance(p.xy, mouseWorld);
          float radius = 180.0;
          float influence = smoothstep(radius, 0.0, d);

          vec2 dir = normalize(p.xy - mouseWorld + 0.0001);
          vec2 swirl = vec2(-dir.y, dir.x);

          float strength = 120.0;
          p.xy += (uMouse * strength) * influence;
          p.xy += swirl * (influence * 30.0);

          vNoise = wave1 + wave2 + wave3;

          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float size = 3.2 + (abs(vNoise) * 0.03);
          gl_PointSize = size * (320.0 / -mvPosition.z);
        }
      `;

      const fragmentShader = `
        varying float vNoise;

        void main(){
          vec2 c = gl_PointCoord - 0.5;
          float dist = length(c);
          float alphaCircle = smoothstep(0.5, 0.0, dist);

          float n = (vNoise + 90.0) / 180.0;
          n = clamp(n, 0.0, 1.0);

          vec3 col1 = vec3(0.06, 0.12, 0.85);
          vec3 col2 = vec3(0.86, 0.15, 0.78);
          vec3 col3 = vec3(0.08, 0.95, 1.0);

          vec3 color = mix(col1, col2, n);
          color = mix(col3, color, 0.15);

          float alpha = alphaCircle * (0.55 + n * 0.75);
          gl_FragColor = vec4(color, alpha);
        }
      `;

      const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader,
        fragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      scene.add(new THREE.Points(geometry, material));

      const geometry2 = buildParticles({ count: 85000, rangeX: 520, rangeY: 280, rangeZ: 520 });
      const uniforms2 = { uTime: { value: 0 }, uMouse: { value: new THREE.Vector2(0, 0) } };

      const vertexShader2 = `
        uniform float uTime;
        uniform vec2 uMouse;
        varying float vNoise;

        void main(){
          vec3 p = position;
          float t = uTime * 0.70;

          float wave1 = sin(p.x * 0.08 + t) * 16.0;
          float wave2 = cos(p.y * 0.09 - t * 1.1) * 16.0;
          float wave3 = sin(p.z * 0.08 + t * 0.9) * 12.0;

          p.x += wave1 + wave3 * 0.25;
          p.y += wave2 + wave3 * 0.25;

          vec2 mouseWorld = vec2(uMouse.x * 420.0, uMouse.y * 240.0);
          float d = distance(p.xy, mouseWorld);
          float radius = 140.0;
          float influence = smoothstep(radius, 0.0, d);

          vec2 dir = normalize(p.xy - mouseWorld + 0.0001);
          vec2 swirl = vec2(-dir.y, dir.x);

          p.xy += (uMouse * 140.0) * influence;
          p.xy += swirl * (influence * 40.0);

          vNoise = wave1 + wave2 + wave3;

          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float size = 4.0 + (abs(vNoise) * 0.05);
          gl_PointSize = size * (360.0 / -mvPosition.z);
        }
      `;

      const fragmentShader2 = `
        varying float vNoise;

        void main(){
          vec2 c = gl_PointCoord - 0.5;
          float dist = length(c);
          float alphaCircle = smoothstep(0.5, 0.0, dist);

          float n = clamp((abs(vNoise)) / 35.0, 0.0, 1.0);

          vec3 col1 = vec3(0.10, 0.25, 1.0);
          vec3 col2 = vec3(1.00, 0.25, 0.90);
          vec3 col3 = vec3(0.20, 1.00, 1.0);

          vec3 color = mix(col1, col2, n);
          color = mix(color, col3, smoothstep(0.35, 1.0, n));

          float alpha = alphaCircle * (0.35 + n * 0.95);
          gl_FragColor = vec4(color, alpha);
        }
      `;

      const material2 = new THREE.ShaderMaterial({
        uniforms: uniforms2,
        vertexShader: vertexShader2,
        fragmentShader: fragmentShader2,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      scene.add(new THREE.Points(geometry2, material2));

      const ring = new THREE.Group();
      scene.add(ring);

      const textureLoader = new THREE.TextureLoader();
      const RADIUS = 260;
      const HEIGHT = 18;
      const PHOTO_W = 92;
      const PHOTO_H = 130;

      const photoMeshes = [];

      MEMORIES.forEach((mem, idx) => {
        const theta = (idx / MEMORIES.length) * Math.PI * 2;
        const x = Math.cos(theta) * RADIUS;
        const z = Math.sin(theta) * RADIUS;
        const y = Math.sin(theta * 2.0) * HEIGHT;

        const geom = new THREE.PlaneGeometry(PHOTO_W, PHOTO_H, 1, 1);

        const mat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 1,
          side: THREE.DoubleSide,
        });
        mat.fog = false;
        mat.depthTest = false;
        mat.depthWrite = false;
        mat.color.setRGB(1.35, 1.35, 1.35);

        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(x, y, z);
        mesh.lookAt(0, 0, 0);
        mesh.userData.memory = mem;
        ring.add(mesh);
        photoMeshes.push(mesh);

        textureLoader.load(
          mem.src,
          (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            tex.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 8);
            mat.map = tex;
            mat.needsUpdate = true;
          },
          undefined,
          () => {
            mat.color.setHex(0x0b0e1a);
            mat.opacity = 1;
          }
        );

        const frameGeom = new THREE.PlaneGeometry(PHOTO_W + 10, PHOTO_H + 10);
        const frameMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
        });
        frameMat.fog = false;
        frameMat.depthTest = false;
        frameMat.depthWrite = false;

        const frame = new THREE.Mesh(frameGeom, frameMat);
        frame.position.copy(mesh.position);
        frame.quaternion.copy(mesh.quaternion);
        frame.translateZ(-1.2);
        ring.add(frame);

        const glowGeom = new THREE.PlaneGeometry(PHOTO_W + 28, PHOTO_H + 28);
        const glowMat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.18,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
        });
        glowMat.fog = false;
        glowMat.depthTest = false;
        glowMat.depthWrite = false;

        const glow = new THREE.Mesh(glowGeom, glowMat);
        glow.position.copy(mesh.position);
        glow.quaternion.copy(mesh.quaternion);
        glow.translateZ(-2.4);
        ring.add(glow);
      });

      let isDown = false;
      let lastX = 0;
      let velocity = 0;
      let rotationY = 0;

      const mouseTarget = new THREE.Vector2(0, 0);
      const mouseSmooth = new THREE.Vector2(0, 0);

      function pointerDown(x) {
        isDown = true;
        lastX = x;
        velocity = 0;
      }

      function pointerMove(x) {
        if (!isDown) return;
        const dx = x - lastX;
        lastX = x;
        const delta = dx * 0.0045;
        rotationY += delta;
        velocity = delta;
      }

      function pointerUp() {
        isDown = false;
      }

      window.addEventListener("mousedown", (e) => pointerDown(e.clientX));
      window.addEventListener("mousemove", (e) => pointerMove(e.clientX));
      window.addEventListener("mouseup", pointerUp);

      window.addEventListener(
        "touchstart",
        (e) => {
          if (!e.touches || !e.touches[0]) return;
          pointerDown(e.touches[0].clientX);
        },
        { passive: true }
      );

      window.addEventListener(
        "touchmove",
        (e) => {
          if (!e.touches || !e.touches[0]) return;
          pointerMove(e.touches[0].clientX);
        },
        { passive: true }
      );

      window.addEventListener("touchend", pointerUp);

      document.addEventListener("keydown", (e) => {
        if (lightbox.classList.contains("active")) return;
        if (e.key === "ArrowLeft") {
          rotationY -= 0.14;
          velocity = -0.07;
        }
        if (e.key === "ArrowRight") {
          rotationY += 0.14;
          velocity = 0.07;
        }
      });

      const raycaster = new THREE.Raycaster();
      const ndc = new THREE.Vector2();

      function tryPick(clientX, clientY) {
        if (Math.abs(velocity) > 0.02 && isDown) return;
        ndc.x = (clientX / window.innerWidth) * 2 - 1;
        ndc.y = -(clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(ndc, camera);

        const hits = raycaster.intersectObjects(photoMeshes, false);
        if (hits && hits.length) {
          const mem = hits[0].object.userData.memory;
          if (mem) openMemory(mem);
        }
      }

      window.addEventListener("click", (e) => {
        if (lightbox.classList.contains("active")) return;
        tryPick(e.clientX, e.clientY);
      });

      window.addEventListener(
        "touchend",
        (e) => {
          if (lightbox.classList.contains("active")) return;
          const t = e.changedTouches && e.changedTouches[0] ? e.changedTouches[0] : null;
          if (!t) return;
          tryPick(t.clientX, t.clientY);
        },
        { passive: true }
      );

      window.addEventListener("mousemove", (e) => {
        const x = e.clientX / window.innerWidth - 0.5;
        const y = e.clientY / window.innerHeight - 0.5;
        mouseTarget.set(x, -y);
      });

      window.addEventListener("mouseleave", () => {
        mouseTarget.set(0, 0);
      });

      function animate() {
        requestAnimationFrame(animate);

        if (!isDown) {
          rotationY += velocity;
          velocity *= 0.92;

          if (!lightbox.classList.contains("active") && Math.abs(velocity) < 0.0005) {
            rotationY += 0.0016;
          }
        }

        ring.rotation.y = rotationY;

        for (let i = 0; i < photoMeshes.length; i++) {
          photoMeshes[i].lookAt(0, 0, 0);
        }

        mouseSmooth.lerp(mouseTarget, 0.14);
        uniforms.uMouse.value.copy(mouseSmooth);
        uniforms2.uMouse.value.copy(mouseSmooth);

        uniforms.uTime.value += 0.05;
        uniforms2.uTime.value += 0.06;

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
